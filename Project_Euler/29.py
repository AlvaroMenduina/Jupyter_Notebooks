"""
Project Euler - Problem 29

Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    2^2=4, 2^3=8, 2^4=16, 2^5=32
    3^2=9, 3^3=27, 3^4=81, 3^5=243
    4^2=16, 4^3=64, 4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

"""

import numpy as np


### Brute force
def powers(a_list, b_list):
    """
    Function that computes all possible combinations of a^b
    and arranges then in order
    :param a_list:
    :param b_list:
    :return:
    """

    power = []
    for a in a_list:
        print("a: ", a)
        _a = []
        for b in b_list:
            power.append(a**b)
            _a.append(a**b)
        print(_a)
    power.sort()

    return np.unique(power)

### Smart approach

def check_if_prime(n):
    # print("\nChecking if %d is prime" % n)
    if n <= 3:
        return n > 1
    elif n % 2 == 0 or n % 3 == 0:
        # print('False (Divisible)')
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            # print('False (Loop)')
            return False
        i += 6
    return True

def primes_up_to_n(n):
    primes = [2, 3]
    for i in np.arange(5, n+1, 2).astype(int):
        if check_if_prime(i):
            primes.append(i)
    return primes

def factors(n, primes_to_use):
    """
    Function to compute the prime factors of n
    and check whether it is of the form prime ** p = n
    i.e. only one distinct prime factor
    :param n:
    :param primes_to_use:
    :return:
    """
    f = []
    for prime in primes_to_use:
        while n % prime == 0:
            f.append(prime)
            n /= prime

    return f


def list_powers(N):

    numbers = list(np.arange(2, N + 1))

    # List the primes
    primes = primes_up_to_n(N)
    not_primes = [s for s in numbers if s not in primes]

    terms, flat_terms = [], []
    for a in numbers:
        a_list = []
        for b in numbers:

            if a in primes:     # If prime just do (a, b)
                _power = [a, b]
                a_list.append(_power)
                if _power not in flat_terms:
                    flat_terms.append(_power)

            if a in not_primes:     # Check if a = (prime_fact) ** p
                prime_fact = factors(a, primes)
                f_unique = np.unique(prime_fact)

                if f_unique.shape[0] != 1:     # Not prime but (p1 * p2) ** b
                    _power = [a for a in prime_fact]
                    _power.append(b)
                    # print(_power)
                    a_list.append(_power)
                    if _power not in flat_terms:
                        flat_terms.append(_power)

                if f_unique.shape[0] == 1:     # a is a prime to a power (p1 ** p) ** b
                    _power = [prime_fact[0], len(prime_fact)*b]
                    a_list.append(_power)
                    if _power not in flat_terms:
                        flat_terms.append(_power)
        print("a: %d" %a, a_list)
        terms.append(a_list)
    return terms, flat_terms




if __name__ == "__main__":

    # Brute Force example
    a = list(np.arange(2, 18+1))
    res = powers(a, a.copy())
    n_unique = len(res)
    print("\nDistinct terms in the sequence for 2 <= a<= 5, 2 <= b <= 5")
    # print(res)
    print("Number of terms: ", n_unique)

    ### Smarter approach
    N = 100
    terms, flat_terms = list_powers(N)
    solution = len(flat_terms)
    print("\nSmarter approach: ", solution)

